// @generated
// This file is @generated by prost-build.
/// Configuration for the distribution manager and workers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    /// Identifier of the distribution strategy.
    ///
    /// The registration strategy are registered with
    /// "REGISTER_Distribution_Manager" method. Make sure to link the
    /// implementation you are using.
    ///
    /// The "MULTI_THREAD" implementation is inefficient and only exist for unit
    /// testing purpose. For non-distributed training, rely on the multi-threading
    /// directly implemented in the learning algorithm.
    #[prost(string, optional, tag="1")]
    pub implementation_key: ::core::option::Option<::prost::alloc::string::String>,
    /// Amount of verbose.
    /// 0: No information.
    /// 1: Small amount of information (e.g. creating of the workers).
    /// 2: Information at every query.
    #[prost(int32, optional, tag="5", default="1")]
    pub verbosity: ::core::option::Option<i32>,
    /// Working directory accessible by the manager and workers. Can be used for
    /// communication by distribution implementations.
    ///
    /// If you are training a model with distributed training, do not specify this
    /// path directly. Instead, specify the "cache_path" of the deployment
    /// configuration (and this path will be set automatically).
    #[prost(string, optional, tag="6")]
    pub working_directory: ::core::option::Option<::prost::alloc::string::String>,
}
/// List of socket addresses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SocketAddresses {
    #[prost(message, repeated, tag="1")]
    pub addresses: ::prost::alloc::vec::Vec<socket_addresses::SocketAddress>,
}
/// Nested message and enum types in `SocketAddresses`.
pub mod socket_addresses {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SocketAddress {
        /// Human readable IP notation e.g. 127.0.0.1.
        #[prost(string, optional, tag="1")]
        pub ip: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="2")]
        pub port: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bns {
    #[prost(string, optional, tag="1")]
    pub prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="2")]
    pub num_workers: ::core::option::Option<i32>,
}
/// Computation distribution over multiple jobs communicating over GRPC. A worker
/// in an instance of ":grpc_worker_main"/
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrpcImp {
    #[prost(bool, optional, tag="3", default="false")]
    pub use_loas: ::core::option::Option<bool>,
    /// Optional global identifier of the distribute session (shared among the
    /// manager and the workers). Useful to differentiate between multiple
    /// distribute sessions running in the same process.
    ///
    /// At a given time, only one manager can be instantiated with the same key in
    /// a given process. Note that many managers can be instantiated without a key.
    #[prost(int32, optional, tag="4")]
    pub key: ::core::option::Option<i32>,
    #[prost(oneof="grpc_imp::WorkerAddress", tags="1, 2, 5")]
    pub worker_address: ::core::option::Option<grpc_imp::WorkerAddress>,
}
/// Nested message and enum types in `GRPCImp`.
pub mod grpc_imp {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WorkerAddress {
        #[prost(message, tag="1")]
        SocketAddresses(super::SocketAddresses),
        #[prost(message, tag="2")]
        Bns(super::Bns),
        #[prost(message, tag="5")]
        GrpcAddresses(super::GrpcAddresses),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrpcAddresses {
    /// Address of the workers.
    ///
    /// Example: "127.0.0.1:2345".
    /// See <https://grpc.github.io/grpc/cpp/md_doc_naming.html> for the supported
    /// formats.
    #[prost(string, repeated, tag="1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Configuration of the workers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerConfig {
    /// Welcome message.
    #[prost(bytes="vec", optional, tag="1")]
    pub welcome_blob: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Addresses of the workers.
    #[prost(string, repeated, tag="2")]
    pub worker_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Unique ID of the manager.
    #[prost(uint64, optional, tag="3")]
    pub manager_uid: ::core::option::Option<u64>,
    /// Job done by the worker.
    #[prost(string, optional, tag="4")]
    pub worker_name: ::core::option::Option<::prost::alloc::string::String>,
    /// "parallel_execution_per_worker" parameter of the manager. How many request
    /// can a worker process in parallel.
    #[prost(int32, optional, tag="5")]
    pub parallel_execution_per_worker: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
    #[prost(bytes="vec", optional, tag="1")]
    pub blob: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag="3")]
    pub manager_uid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag="4")]
    pub worker_idx: ::core::option::Option<i32>,
    #[prost(message, optional, tag="5")]
    pub worker_config: ::core::option::Option<WorkerConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Answer {
    #[prost(bytes="vec", optional, tag="1")]
    pub blob: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag="2")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShutdownQuery {
    #[prost(bool, optional, tag="1")]
    pub kill_worker_manager: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerQuery {
    #[prost(bytes="vec", optional, tag="1")]
    pub blob: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag="3")]
    pub manager_uid: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerAnswer {
    #[prost(bytes="vec", optional, tag="1")]
    pub blob: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag="2")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerAddressQuery {
    #[prost(int32, optional, tag="1")]
    pub worker_idx: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub new_address: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Empty {
}
/// In process, non-parallelized distribution. For debugging and pipeline
/// development.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MultiThreadImp {
    /// Number of workers / threads.
    #[prost(int32, optional, tag="1", default="10")]
    pub num_workers: ::core::option::Option<i32>,
}
// @@protoc_insertion_point(module)
