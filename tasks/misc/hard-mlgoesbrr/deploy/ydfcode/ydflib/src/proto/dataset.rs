// @generated
// This file is @generated by prost-build.
/// Specification of the columns of a dataset. List the available columns (
/// including their name, type, and extra information e.g. dictionaries).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSpecification {
    /// The columns.
    #[prost(message, repeated, tag="1")]
    pub columns: ::prost::alloc::vec::Vec<Column>,
    /// The number of rows of the dataset used to create this dataspec (if a
    /// dataset was used).
    #[prost(int64, optional, tag="2")]
    pub created_num_rows: ::core::option::Option<i64>,
    /// Meta-data about features that were unstacked e.g. with the
    /// "unstack_numerical_set_as_numericals" control field.
    #[prost(message, repeated, tag="3")]
    pub unstackeds: ::prost::alloc::vec::Vec<Unstacked>,
}
/// Definition of a column in a dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Column {
    /// Type of data.
    #[prost(enumeration="ColumnType", optional, tag="1", default="Unknown")]
    pub r#type: ::core::option::Option<i32>,
    /// Column unique name.
    #[prost(string, optional, tag="2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// If true, the type is set manually by the user (instead of been
    /// automatically detected). This field is purely used for debugging purpose
    /// and has no impact on the computation. Note that if a column guide matches
    /// this column, and if this column guide does not contain a type,
    /// is_manual_type is set to false (as if there were no column guide match).
    #[prost(bool, optional, tag="3", default="false")]
    pub is_manual_type: ::core::option::Option<bool>,
    /// Tokenization. For non-integerized list or sets columns (numerical or
    /// categorical).
    #[prost(message, optional, tag="4")]
    pub tokenizer: ::core::option::Option<Tokenizer>,
    /// Data for numerical (simple, list or set) attribute types.
    #[prost(message, optional, tag="5")]
    pub numerical: ::core::option::Option<NumericalSpec>,
    /// Data for categorical (simple, list or set) attribute types.
    #[prost(message, optional, tag="6")]
    pub categorical: ::core::option::Option<CategoricalSpec>,
    /// Number of NAs (i.e. not available) record when building the dataspec.
    #[prost(int64, optional, tag="7", default="0")]
    pub count_nas: ::core::option::Option<i64>,
    /// Numerical value stored as an index + a dictionary.
    #[prost(message, optional, tag="8")]
    pub discretized_numerical: ::core::option::Option<DiscretizedNumericalSpec>,
    /// Data for boolean attribute types.
    #[prost(message, optional, tag="9")]
    pub boolean: ::core::option::Option<BooleanSpec>,
    /// For all the types defined as a collection of multiple values.
    #[prost(message, optional, tag="10")]
    pub multi_values: ::core::option::Option<MultiValuesSpec>,
    /// Is the feature derived from unstacking a multi-dimensional dimension?
    #[prost(bool, optional, tag="11", default="false")]
    pub is_unstacked: ::core::option::Option<bool>,
    /// Storage representation of a column.
    /// Internally, feature representation is determined by its semantic. For
    /// instance, a NUMERICAL feature is always stored as a float32. DTypes are
    /// used to record the feature representation fed to YDF, and then used for
    /// APIs without automatic casting.
    #[prost(enumeration="DType", optional, tag="12")]
    pub dtype: ::core::option::Option<i32>,
}
/// Specification of a categorical column.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CategoricalSpec {
    /// The most frequent value.
    #[prost(int64, optional, tag="1")]
    pub most_frequent_value: ::core::option::Option<i64>,
    /// The number of unique values (including the reserved OOD(=0) value).
    /// All the values should be 0 <= value < number_of_unique_values.
    ///
    /// The value "0" is reserved for the out-of-dictionary value. Therefore, in
    /// the case of a categorical column with two possible values "X" and "Y", the
    /// proto will be:
    ///
    ///    number_of_unique_values = 3
    ///    is_already_integerized=false
    ///    items { key: "OOD" value { index: 0 }}
    ///    items { key: "X" value { index: 1 }}
    ///    items { key: "Y" value { index: 2 }}
    ///
    /// Missing values are implicit and take index=-1. They don't need to be
    /// specified in "items".
    #[prost(int64, optional, tag="2")]
    pub number_of_unique_values: ::core::option::Option<i64>,
    /// Minimum frequency of a value not to be replaced by the <OOD> special
    /// value. Used when computing value dictionary.
    #[prost(int32, optional, tag="3", default="5")]
    pub min_value_count: ::core::option::Option<i32>,
    /// Maximum number of unique categorical values. If more values are present,
    /// the less frequent values are considered <OOD>. Used when computing value
    /// dictionary. If "max_number_of_unique_values" == -1, the items are not
    /// pruned.
    #[prost(int32, optional, tag="4", default="2000")]
    pub max_number_of_unique_values: ::core::option::Option<i32>,
    /// If true, values are interpreted directed as an integer. If false, values
    /// are indexed in the "items" dictionary.
    #[prost(bool, optional, tag="5")]
    pub is_already_integerized: ::core::option::Option<bool>,
    /// Dictionary of values. Only available if is_already_integerized=false. In
    /// this case, items.size() is equal to number_of_unique_values.
    #[prost(map="string, message", tag="7")]
    pub items: ::std::collections::HashMap<::prost::alloc::string::String, categorical_spec::VocabValue>,
    /// If true, integer categorical values provided by the user have been offset
    /// by 1. Such pre-processing is done in TensorFlow Decision Forests. See
    /// "CATEGORICAL_INTEGER_OFFSET".
    #[prost(bool, optional, tag="8", default="false")]
    pub offset_value_by_one_during_training: ::core::option::Option<bool>,
}
/// Nested message and enum types in `CategoricalSpec`.
pub mod categorical_spec {
    /// Possible value of a non integerized categorical, categorical set, or
    /// categorical list attribute.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct VocabValue {
        /// Index of the value.
        #[prost(int64, optional, tag="1")]
        pub index: ::core::option::Option<i64>,
        /// Frequency of the value.
        #[prost(int64, optional, tag="2")]
        pub count: ::core::option::Option<i64>,
    }
}
/// Specification of a numerical column.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NumericalSpec {
    /// Mean value (excluding the NaN).
    #[prost(double, optional, tag="1", default="0")]
    pub mean: ::core::option::Option<f64>,
    #[prost(float, optional, tag="2")]
    pub min_value: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub max_value: ::core::option::Option<f32>,
    #[prost(double, optional, tag="4")]
    pub standard_deviation: ::core::option::Option<f64>,
}
/// Specification for types with multiple values.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MultiValuesSpec {
    /// Maximum number of observed items.
    #[prost(int32, optional, tag="1")]
    pub max_observed_size: ::core::option::Option<i32>,
    /// Minimum number of observed items.
    ///
    /// Note: Depending on the type of the column, observations with more values
    /// than "max_observed_size" or less values than "min_observed_size" might
    /// still be valid.
    #[prost(int32, optional, tag="2")]
    pub min_observed_size: ::core::option::Option<i32>,
}
/// Specification of a boolean column.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BooleanSpec {
    /// Number of true values.
    #[prost(int64, optional, tag="1")]
    pub count_true: ::core::option::Option<i64>,
    /// Number of false values.
    #[prost(int64, optional, tag="2")]
    pub count_false: ::core::option::Option<i64>,
}
/// Specification of a discretized numerical column.
///
/// A "discretized numerical" value "i" is encoded as index (integer) between -1
/// (inclusive) and "n = boundaries.size()" (also inclusive).
///    If i==-1, the value is missing.
///    If i==0, the original numerical value is lower (strictly) than
///    "boundaries.front()". If i==boundaries.size(), the original value is higher
///    (non strictly) to "boundaries.back()". If i \in [1, boundaries.size()[, the
///    original value is in between "boundaries\[i-1\]" and "boundaries\[i\]".
///
/// Because encoding a numerical value into a discretized numerical value is
/// lossy, the original numerical value cannot be recovered. In this case, the
/// following logic is applied:
///    If i==-1, the numercal value is "std::nan" (corresponding to a missing
///    value). If i==0, the numerical value is "boundaries.front()-1". If
///    i==boundaries.size(), the numerical value is "boundaries.back()+1". If i
///    \in [1, boundaries.size()[, the numerical value is
///    "(boundaries\[i-1\]+boundaries\[i\])/2".
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscretizedNumericalSpec {
    /// Boundaries in between the bins.
    /// The number of bins is boundaries.size() + 1.
    #[prost(float, repeated, tag="1")]
    pub boundaries: ::prost::alloc::vec::Vec<f32>,
    /// Number of unique numerical values before the discretization.
    #[prost(int64, optional, tag="2")]
    pub original_num_unique_values: ::core::option::Option<i64>,
    /// Maximum number of bins (at construction time).
    /// // Defaults to 255 bins, that is 254 boundaries.
    #[prost(int64, optional, tag="3", default="255")]
    pub maximum_num_bins: ::core::option::Option<i64>,
    /// Minimum number of examples in a bin.
    #[prost(int32, optional, tag="4", default="3")]
    pub min_obs_in_bins: ::core::option::Option<i32>,
}
/// Tokenization parameters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tokenizer {
    /// How to convert a string into a list/set of symbols.
    #[prost(enumeration="tokenizer::Splitter", optional, tag="1", default="Separator")]
    pub splitter: ::core::option::Option<i32>,
    /// Separator characters. Used if splitter=SEPARATOR.
    #[prost(string, optional, tag="2", default=" ;,")]
    pub separator: ::core::option::Option<::prost::alloc::string::String>,
    /// Splitting regular expression. Used if splitter=REGEX_MATCH.
    #[prost(string, optional, tag="3", default="([\\S]+)")]
    pub regex: ::core::option::Option<::prost::alloc::string::String>,
    /// Cast strings to lower case before tokenization.
    #[prost(bool, optional, tag="4", default="true")]
    pub to_lower_case: ::core::option::Option<bool>,
    /// Grouping of the tokens.
    #[prost(message, optional, tag="5")]
    pub grouping: ::core::option::Option<tokenizer::Grouping>,
}
/// Nested message and enum types in `Tokenizer`.
pub mod tokenizer {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Grouping {
        #[prost(bool, optional, tag="1", default="true")]
        pub unigrams: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="2", default="false")]
        pub bigrams: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="3", default="false")]
        pub trigrams: ::core::option::Option<bool>,
    }
    /// Possible string tokenization algorithms.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Splitter {
        Invalid = 0,
        /// Split a string according to the user specified separator.
        Separator = 1,
        /// Split a string by extracting token using the user specified regular
        /// expression.
        RegexMatch = 2,
        /// Split a string into individual characters. Does not remove spaces and
        /// non-printable characters.
        Character = 3,
        /// Never split a string. Useful if CATEGORICAL_SET features should be
        /// avoided.
        NoSplitting = 4,
    }
    impl Splitter {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Splitter::Invalid => "INVALID",
                Splitter::Separator => "SEPARATOR",
                Splitter::RegexMatch => "REGEX_MATCH",
                Splitter::Character => "CHARACTER",
                Splitter::NoSplitting => "NO_SPLITTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID" => Some(Self::Invalid),
                "SEPARATOR" => Some(Self::Separator),
                "REGEX_MATCH" => Some(Self::RegexMatch),
                "CHARACTER" => Some(Self::Character),
                "NO_SPLITTING" => Some(Self::NoSplitting),
                _ => None,
            }
        }
    }
}
/// Information about unstacked column. An unstacked column is a
/// multi-dimensional column (e.g. an embedding) that has been split into
/// multiple scalar columns.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unstacked {
    /// Name of the column that was unstacked.
    #[prost(string, optional, tag="1")]
    pub original_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Index of the first column containing the unstacked feature.
    #[prost(int32, optional, tag="2")]
    pub begin_column_idx: ::core::option::Option<i32>,
    /// Number of unstacked elements.
    #[prost(int32, optional, tag="3")]
    pub size: ::core::option::Option<i32>,
    /// Type of the columns.
    #[prost(enumeration="ColumnType", optional, tag="4", default="Unknown")]
    pub r#type: ::core::option::Option<i32>,
}
/// Configuration for the automated "inference" logic of the data specification
/// (see header for the definition of data specification).
/// For example, the DataSpecificationGuide allows to express the following:
///    - The column called "feature_1" is NUMERICAL.
///    - The columns matching the regex "num_feature_.*" are NUMERICAL.
///    - Ignore the column called "feature_1".
///    - Ignore the columns matching the regex "num_feature_.*".
///    - Ignore the columns matching none of the set rules.
///    - The column called "feature_1" is a CATEGORICAL_SET and should be
///      tokenized by commas.
///    - The column called "feature_1" is a CATEGORICAL and the categorical
///      values seen less than 50 times should be ignored (considered out-of-bag).
///    - The size of the CATEGORICAL and CATEGORICAL_SET column dictionaries
///      should not have more than 1000 items.
///    - Column that look BOOLEAN should be interpreted as NUMERICAL.
///    - Use the first 100'000 record in the dataset to best infer the semantic of
///      the columns.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSpecificationGuide {
    /// Guide applied to one or a sub-set of columns according to a regular
    /// expression match.
    #[prost(message, repeated, tag="1")]
    pub column_guides: ::prost::alloc::vec::Vec<ColumnGuide>,
    /// Default guide for all columns.
    /// Also apply to columns matched with "column_guides", but with a lower
    /// priority. For example, if an configuration option is set both in
    /// "default_column_guide" and "column_guides", the value is "column_guides"
    /// will be used.
    #[prost(message, optional, tag="2")]
    pub default_column_guide: ::core::option::Option<ColumnGuide>,
    /// If true, columns that don't match any "column_guides" regular expression
    /// are ignored.
    #[prost(bool, optional, tag="3", default="false")]
    pub ignore_columns_without_guides: ::core::option::Option<bool>,
    /// Maximum number of rows to scan to infer the column types.
    /// Set the value "-1" to use all rows (i.e. use the entire dataset).
    /// Note: The type inference logic is only used if the user does not specify
    /// the type manually.
    #[prost(int64, optional, tag="4", default="1000")]
    pub max_num_scanned_rows_to_guess_type: ::core::option::Option<i64>,
    /// If true, columns initially detected as BOOLEAN (i.e. only containing "0"
    /// and "1" values) will be detected as NUMERICAL.
    #[prost(bool, optional, tag="5", default="false")]
    pub detect_boolean_as_numerical: ::core::option::Option<bool>,
    /// Detects numerical values (i.e. NUMERICAL) as DISCRETIZED_NUMERICAL.
    /// DISCRETIZED_NUMERICAL values are discretized at loading time. Some
    /// algorithms (e.g. the YDF decision forest algorithms) will handle
    /// NUMERICAL and DISCRETIZED_NUMERICAL types differently. Generally,
    /// discretized columns are faster to train but can lead to sub-optimal models.
    #[prost(bool, optional, tag="6", default="false")]
    pub detect_numerical_as_discretized_numerical: ::core::option::Option<bool>,
    /// Maximum number of rows to scan to compute column statistics (e.g.
    /// dictionary, ratio of missing values, mean value).
    /// Set the value "-1" to use all rows (i.e. use the entire dataset).
    #[prost(int64, optional, tag="7", default="-1")]
    pub max_num_scanned_rows_to_accumulate_statistics: ::core::option::Option<i64>,
    /// If true, unstack numerical sets are multiple numerical features. This
    /// operation is useful to consume multi-dimensional numerical vectors i.e.
    /// list of numerical values with always the same size and semantic per
    /// dimension.
    #[prost(bool, optional, tag="8", default="true")]
    pub unstack_numerical_set_as_numericals: ::core::option::Option<bool>,
    /// Remove columns of unknown type. For example, if the column has no values
    /// (all the values are missing) and its type is not specified by the user.
    #[prost(bool, optional, tag="9", default="false")]
    pub ignore_unknown_type_columns: ::core::option::Option<bool>,
    /// Allow automatic inference of the CATEGORICAL_SET type by applying
    /// tokenization. If not set, the inference code will still set the type to
    /// CATEGORICAL_SET if the (default) column guide asks for it.
    #[prost(bool, optional, tag="10", default="true")]
    pub allow_tokenization_for_inference_as_categorical_set: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnGuide {
    /// Regular expression on the column name.
    #[prost(string, optional, tag="1")]
    pub column_name_pattern: ::core::option::Option<::prost::alloc::string::String>,
    /// Type of the column.
    #[prost(enumeration="ColumnType", optional, tag="2")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(message, optional, tag="3")]
    pub categorial: ::core::option::Option<CategoricalGuide>,
    #[prost(message, optional, tag="4")]
    pub numerical: ::core::option::Option<NumericalGuide>,
    /// If "tokenizer" is specified, and if the dataset container can represent a
    /// list of token natively (i.e. list of strings e.g. tf.Example), the first
    /// string entry (if any) will be tokenized. If the attribute contains more
    /// than one entry, an error will be raised.
    #[prost(message, optional, tag="5")]
    pub tokenizer: ::core::option::Option<TokenizerGuide>,
    /// If true, a column can be matched against multiple different "ColumnGuide"
    /// with the last ColumnGuide having higher priority. For example, it the
    /// "type" is set in two matching column guides, the type defined in the last
    /// column guide will be used. If false, an error will be raised if more than
    /// one column guide is matching a column.
    #[prost(bool, optional, tag="6", default="false")]
    pub allow_multi_match: ::core::option::Option<bool>,
    #[prost(message, optional, tag="7")]
    pub discretized_numerical: ::core::option::Option<DiscretizedNumericalGuide>,
    /// If true, matching columns are ignored and won't be in the dataspec.
    #[prost(bool, optional, tag="8", default="false")]
    pub ignore_column: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CategoricalGuide {
    /// Minimum frequency of an categorical value not to be replaced by the <RARE>
    /// special value.
    #[prost(int32, optional, tag="1", default="5")]
    pub min_vocab_frequency: ::core::option::Option<i32>,
    /// Maximum number of unique categorical values. If more values are present,
    /// the less frequent values are considered <OOD>.
    #[prost(int32, optional, tag="2", default="2000")]
    pub max_vocab_count: ::core::option::Option<i32>,
    /// If is_already_integerized=false, a dictionary is build for the feature.
    /// Even if the feature is an integer or a float. If
    /// is_already_integerized=true, the value is directly interpreted as an
    /// index and should follow the following convention:
    ///    - The value should be greater or equal to -1.
    ///    - The value -1 is the "missing value".
    ///    - The value 0 is the "out-of-dictionary value".
    ///    - Several YDF algorithms assume this is a "dense index" i.e. if the
    ///      column is an input feature, it is best to have it being dense.
    #[prost(bool, optional, tag="3")]
    pub is_already_integerized: ::core::option::Option<bool>,
    /// If "is_already_integerized=true" and if
    /// "number_of_already_integerized_values" is set,
    /// "number_of_already_integerized_values" is the number of unique values. Such
    /// attribute accepts values in [-1, number_of_already_integerized_values).
    /// Values outside of this range will be considered "out-of-vocabulary".
    ///
    /// Note that if the dataset used to infer the dataspec contains an example
    /// with a value > number_of_already_integerized_values, the example value will
    /// be used instead of "number_of_already_integerized_values".
    #[prost(int64, optional, tag="4")]
    pub number_of_already_integerized_values: ::core::option::Option<i64>,
    /// If set, replaces the most_frequent_item item. The most frequent item is
    /// used by the global imputation algorithm to handle missing values. That is,
    /// missing values will be treated as the most frequent item. Overriding the
    /// most frequent item is only allowed on columns not containing any missing
    /// values.
    #[prost(message, optional, tag="5")]
    pub override_most_frequent_item: ::core::option::Option<categorical_guide::OverrideMostFrequentItem>,
}
/// Nested message and enum types in `CategoricalGuide`.
pub mod categorical_guide {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OverrideMostFrequentItem {
        /// Overriding is only possible for non-integerized columns.
        #[prost(string, optional, tag="5")]
        pub str_value: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NumericalGuide {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenizerGuide {
    #[prost(message, optional, tag="1")]
    pub tokenizer: ::core::option::Option<Tokenizer>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DiscretizedNumericalGuide {
    #[prost(int64, optional, tag="1", default="255")]
    pub maximum_num_bins: ::core::option::Option<i64>,
    /// Minimum number of examples in a bin.
    #[prost(int32, optional, tag="2", default="3")]
    pub min_obs_in_bins: ::core::option::Option<i32>,
}
/// Structure containing intermediary information for the computation of
/// a DataSpecification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSpecificationAccumulator {
    #[prost(message, repeated, tag="1")]
    pub columns: ::prost::alloc::vec::Vec<data_specification_accumulator::Column>,
}
/// Nested message and enum types in `DataSpecificationAccumulator`.
pub mod data_specification_accumulator {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Column {
        /// Sum and sum of error for the Kahan summation. Used for numerical columns.
        #[prost(double, optional, tag="1")]
        pub kahan_sum: ::core::option::Option<f64>,
        #[prost(double, optional, tag="2")]
        pub kahan_sum_error: ::core::option::Option<f64>,
        #[prost(double, optional, tag="3")]
        pub min_value: ::core::option::Option<f64>,
        #[prost(double, optional, tag="4")]
        pub max_value: ::core::option::Option<f64>,
        #[prost(double, optional, tag="6")]
        pub kahan_sum_of_square: ::core::option::Option<f64>,
        #[prost(double, optional, tag="7")]
        pub kahan_sum_of_square_error: ::core::option::Option<f64>,
        /// Mapping between float values (represented as an uint32) and the number of
        /// times this value was saw.
        ///
        /// Note: Map don't allow float indexed maps.
        #[prost(map="fixed32, int32", tag="5")]
        pub discretized_numerical: ::std::collections::HashMap<u32, i32>,
    }
}
/// Type of dataset columns.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ColumnType {
    Unknown = 0,
    Numerical = 1,
    NumericalSet = 2,
    NumericalList = 3,
    Categorical = 4,
    CategoricalSet = 5,
    CategoricalList = 6,
    Boolean = 7,
    String = 8,
    DiscretizedNumerical = 9,
    Hash = 10,
}
impl ColumnType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ColumnType::Unknown => "UNKNOWN",
            ColumnType::Numerical => "NUMERICAL",
            ColumnType::NumericalSet => "NUMERICAL_SET",
            ColumnType::NumericalList => "NUMERICAL_LIST",
            ColumnType::Categorical => "CATEGORICAL",
            ColumnType::CategoricalSet => "CATEGORICAL_SET",
            ColumnType::CategoricalList => "CATEGORICAL_LIST",
            ColumnType::Boolean => "BOOLEAN",
            ColumnType::String => "STRING",
            ColumnType::DiscretizedNumerical => "DISCRETIZED_NUMERICAL",
            ColumnType::Hash => "HASH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "NUMERICAL" => Some(Self::Numerical),
            "NUMERICAL_SET" => Some(Self::NumericalSet),
            "NUMERICAL_LIST" => Some(Self::NumericalList),
            "CATEGORICAL" => Some(Self::Categorical),
            "CATEGORICAL_SET" => Some(Self::CategoricalSet),
            "CATEGORICAL_LIST" => Some(Self::CategoricalList),
            "BOOLEAN" => Some(Self::Boolean),
            "STRING" => Some(Self::String),
            "DISCRETIZED_NUMERICAL" => Some(Self::DiscretizedNumerical),
            "HASH" => Some(Self::Hash),
            _ => None,
        }
    }
}
/// Storage representation of a column.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DType {
    DtypeInvalid = 0,
    DtypeInt8 = 1,
    DtypeInt16 = 2,
    DtypeInt32 = 3,
    DtypeInt64 = 4,
    DtypeUint8 = 5,
    DtypeUint16 = 6,
    DtypeUint32 = 7,
    DtypeUint64 = 8,
    DtypeFloat16 = 9,
    DtypeFloat32 = 10,
    DtypeFloat64 = 11,
    DtypeBool = 12,
    DtypeBytes = 13,
}
impl DType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DType::DtypeInvalid => "DTYPE_INVALID",
            DType::DtypeInt8 => "DTYPE_INT8",
            DType::DtypeInt16 => "DTYPE_INT16",
            DType::DtypeInt32 => "DTYPE_INT32",
            DType::DtypeInt64 => "DTYPE_INT64",
            DType::DtypeUint8 => "DTYPE_UINT8",
            DType::DtypeUint16 => "DTYPE_UINT16",
            DType::DtypeUint32 => "DTYPE_UINT32",
            DType::DtypeUint64 => "DTYPE_UINT64",
            DType::DtypeFloat16 => "DTYPE_FLOAT16",
            DType::DtypeFloat32 => "DTYPE_FLOAT32",
            DType::DtypeFloat64 => "DTYPE_FLOAT64",
            DType::DtypeBool => "DTYPE_BOOL",
            DType::DtypeBytes => "DTYPE_BYTES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DTYPE_INVALID" => Some(Self::DtypeInvalid),
            "DTYPE_INT8" => Some(Self::DtypeInt8),
            "DTYPE_INT16" => Some(Self::DtypeInt16),
            "DTYPE_INT32" => Some(Self::DtypeInt32),
            "DTYPE_INT64" => Some(Self::DtypeInt64),
            "DTYPE_UINT8" => Some(Self::DtypeUint8),
            "DTYPE_UINT16" => Some(Self::DtypeUint16),
            "DTYPE_UINT32" => Some(Self::DtypeUint32),
            "DTYPE_UINT64" => Some(Self::DtypeUint64),
            "DTYPE_FLOAT16" => Some(Self::DtypeFloat16),
            "DTYPE_FLOAT32" => Some(Self::DtypeFloat32),
            "DTYPE_FLOAT64" => Some(Self::DtypeFloat64),
            "DTYPE_BOOL" => Some(Self::DtypeBool),
            "DTYPE_BYTES" => Some(Self::DtypeBytes),
            _ => None,
        }
    }
}
/// One Example (also called observation/record/example/sample).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Example {
    /// Attribute values indexed by the attribute index defined in the dataspec.
    #[prost(message, repeated, tag="1")]
    pub attributes: ::prost::alloc::vec::Vec<example::Attribute>,
    /// Example index.
    #[prost(int64, optional, tag="2")]
    pub example_idx: ::core::option::Option<i64>,
}
/// Nested message and enum types in `Example`.
pub mod example {
    /// Value for multi-dimensional categorical attributes.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CategoricalVector {
        #[prost(int32, repeated, tag="1")]
        pub values: ::prost::alloc::vec::Vec<i32>,
    }
    /// Value for multi-dimensional numerical attributes.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NumericalVector {
        #[prost(float, repeated, tag="1")]
        pub values: ::prost::alloc::vec::Vec<f32>,
    }
    /// Attribute value.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Attribute {
        #[prost(oneof="attribute::Type", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
        pub r#type: ::core::option::Option<attribute::Type>,
    }
    /// Nested message and enum types in `Attribute`.
    pub mod attribute {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Type {
            #[prost(bool, tag="1")]
            Boolean(bool),
            #[prost(float, tag="2")]
            Numerical(f32),
            #[prost(int32, tag="3")]
            Categorical(i32),
            #[prost(string, tag="4")]
            Text(::prost::alloc::string::String),
            #[prost(message, tag="5")]
            CategoricalList(super::CategoricalVector),
            #[prost(message, tag="6")]
            CategoricalSet(super::CategoricalVector),
            #[prost(message, tag="7")]
            NumericalList(super::NumericalVector),
            #[prost(message, tag="8")]
            NumericalSet(super::NumericalVector),
            /// Note: This value will be loaded as a "DiscretizedNumericalIndex =
            /// uint16".
            #[prost(int32, tag="9")]
            DiscretizedNumerical(i32),
            #[prost(uint64, tag="10")]
            Hash(u64),
        }
    }
}
/// Supported dataset formats.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatasetFormat {
    Invalid = 0,
    FormatCsv = 1,
    FormatTfeTfrecord = 5,
    FormatTfeTfrecordv2 = 8,
    FormatPartialDatasetCache = 7,
}
impl DatasetFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DatasetFormat::Invalid => "INVALID",
            DatasetFormat::FormatCsv => "FORMAT_CSV",
            DatasetFormat::FormatTfeTfrecord => "FORMAT_TFE_TFRECORD",
            DatasetFormat::FormatTfeTfrecordv2 => "FORMAT_TFE_TFRECORDV2",
            DatasetFormat::FormatPartialDatasetCache => "FORMAT_PARTIAL_DATASET_CACHE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INVALID" => Some(Self::Invalid),
            "FORMAT_CSV" => Some(Self::FormatCsv),
            "FORMAT_TFE_TFRECORD" => Some(Self::FormatTfeTfrecord),
            "FORMAT_TFE_TFRECORDV2" => Some(Self::FormatTfeTfrecordv2),
            "FORMAT_PARTIAL_DATASET_CACHE" => Some(Self::FormatPartialDatasetCache),
            _ => None,
        }
    }
}
/// Options for the synthetic generation of dataset.
///
/// Next ID: 21
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyntheticDatasetOptions {
    /// Number of examples in the dataset.
    #[prost(int32, optional, tag="1", default="5000")]
    pub num_examples: ::core::option::Option<i32>,
    /// Name of the label column.
    #[prost(string, optional, tag="2", default="LABEL")]
    pub label_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of the feature columns, with "{type}" being the short feature type
    /// (e.g. "num(erical)", "cat(egorical)")  and "{index}" being the feature
    /// index (among other features of the same type).
    #[prost(string, optional, tag="3", default="{type}_{index}")]
    pub feature_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Number of features by semantic.
    ///
    /// "num_categorical" and "num_categorical_set" are used each twice for the
    /// string and integer representations e.g. categorical_string,
    /// categorical_int.
    #[prost(int32, optional, tag="4", default="2")]
    pub num_numerical: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5", default="2")]
    pub num_categorical: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6", default="2")]
    pub num_categorical_set: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="7", default="2")]
    pub num_boolean: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="18", default="0")]
    pub num_multidimensional_numerical: ::core::option::Option<i32>,
    /// Dictionary sizes.
    #[prost(int32, optional, tag="8", default="30")]
    pub categorical_vocab_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="9", default="30")]
    pub categorical_set_vocab_size: ::core::option::Option<i32>,
    /// Number of dimensions of "multidimensional_numerical" features.
    #[prost(int32, optional, tag="19", default="5")]
    pub multidimensional_numerical_dim: ::core::option::Option<i32>,
    /// If false, numerical values represented as float. If true, they are
    /// represented as integers.
    #[prost(bool, optional, tag="20", default="false")]
    pub represent_numerical_as_integer: ::core::option::Option<bool>,
    /// If true, the value zero (0) of categorical and categorical set values (both
    /// for features and labels) is used to represent a out-of-vocabulary value
    /// (and the first real value is 1). If false, zero (0) is a categorical value
    /// like others.
    #[prost(bool, optional, tag="17", default="true")]
    pub zero_categorical_int_value_is_oov: ::core::option::Option<bool>,
    /// Average number of items in a categorical set feature.
    #[prost(int32, optional, tag="10", default="3")]
    pub categorical_set_mean_size: ::core::option::Option<i32>,
    /// Probability for a feature value to be missing.
    #[prost(float, optional, tag="11", default="0.05")]
    pub missing_ratio: ::core::option::Option<f32>,
    /// How much noise to inject in the label.
    ///
    /// The problem can be perfectly solved with "label_noise_ratio=0", and not be
    /// solved better than random for "label_noise_ratio=1" (is there are not other
    /// sources of noise).
    #[prost(float, optional, tag="12", default="0.05")]
    pub label_noise_ratio: ::core::option::Option<f32>,
    /// Seed used to initialize the random generator used to generate the dataset.
    /// If set to -1, the random generator is initialized using std::random_device.
    #[prost(int32, optional, tag="13", default="12345")]
    pub seed: ::core::option::Option<i32>,
    /// Number of accumulators. Accumulator are internal structures used to
    /// generate the dataset.
    ///
    /// Increasing the value will increase the "conditional independence" of the
    /// dataset i.e. having more tuples <FS1, FS2, X> such that
    /// "Label ⊥ FS1 | FS2=X" with FS1 and FS2 two sets of features.
    ///
    /// Decreasing the value will make the dataset more "naive independent" i.e.
    /// increasing the tendency of "P(Label Fi | Fj) == P(Label Fi) if j!=i".
    ///
    /// The value should be odd and in between 1 and the total number of features
    /// (i.e. sum "num_{numerical, categorical, ...}"). Even values will be rounded
    /// down.
    ///
    /// The exact use of the accumulators is described in "synthetic_dataset.h".
    #[prost(int32, optional, tag="14", default="5")]
    pub num_accumulators: ::core::option::Option<i32>,
    /// Number of examples to inject in each shards. Requires for the dataset paths
    /// to be sharded (i.e. ends with @<number of shards>). Set to -1 to disable
    /// dataset sharding.
    #[prost(int64, optional, tag="22", default="-1")]
    pub num_examples_per_shards: ::core::option::Option<i64>,
    /// The task represented by the labels.
    #[prost(oneof="synthetic_dataset_options::Task", tags="15, 16, 21")]
    pub task: ::core::option::Option<synthetic_dataset_options::Task>,
}
/// Nested message and enum types in `SyntheticDatasetOptions`.
pub mod synthetic_dataset_options {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Classification {
        /// Number of label classes. 2 => binary classification.
        #[prost(int32, optional, tag="1", default="2")]
        pub num_classes: ::core::option::Option<i32>,
        /// Is the label stored a string or an integer.
        #[prost(bool, optional, tag="2", default="true")]
        pub store_label_as_str: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Regression {
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Ranking {
        /// Name of the column containing the group index. In document/query scoring,
        /// the group would be the queries.
        #[prost(string, optional, tag="1", default="GROUP")]
        pub group_name: ::core::option::Option<::prost::alloc::string::String>,
        /// Number of examples in each group.
        /// The last group might have less examples if num_examples % group_size !=
        /// 0.
        #[prost(int32, optional, tag="2", default="10")]
        pub group_size: ::core::option::Option<i32>,
    }
    /// The task represented by the labels.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Task {
        /// Default.
        #[prost(message, tag="15")]
        Classification(Classification),
        #[prost(message, tag="16")]
        Regression(Regression),
        #[prost(message, tag="21")]
        Ranking(Ranking),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightDefinition {
    /// \[Required\] Name of the attribute that controls the weights of the examples.
    #[prost(string, optional, tag="1")]
    pub attribute: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof="weight_definition::Type", tags="2, 3")]
    pub r#type: ::core::option::Option<weight_definition::Type>,
}
/// Nested message and enum types in `WeightDefinition`.
pub mod weight_definition {
    /// The weight is directly the numerical value.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NumericalWeight {
    }
    /// Solve the following mapping to get the weight.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CategoricalWeight {
        /// Pair of categorical value and weight.
        #[prost(message, repeated, tag="1")]
        pub items: ::prost::alloc::vec::Vec<categorical_weight::Item>,
    }
    /// Nested message and enum types in `CategoricalWeight`.
    pub mod categorical_weight {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Item {
            /// \[Required\] A value to map to a corresponding weight.
            #[prost(string, optional, tag="1")]
            pub value: ::core::option::Option<::prost::alloc::string::String>,
            /// \[Required\] The weight.
            #[prost(float, optional, tag="3")]
            pub weight: ::core::option::Option<f32>,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// The attribute is interpreted as a numerical value.
        #[prost(message, tag="2")]
        Numerical(NumericalWeight),
        /// The attribute is interpreted as a categorical attribute. A weight is
        /// defined for each possible value.
        #[prost(message, tag="3")]
        Categorical(CategoricalWeight),
    }
}
/// Internal linked version of the weight definition. The attributes and values
/// are indexed according to the dataspec.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkedWeightDefinition {
    /// Attribute index used to compute the weight.
    #[prost(int32, optional, tag="1")]
    pub attribute_idx: ::core::option::Option<i32>,
    #[prost(oneof="linked_weight_definition::Type", tags="2, 3")]
    pub r#type: ::core::option::Option<linked_weight_definition::Type>,
}
/// Nested message and enum types in `LinkedWeightDefinition`.
pub mod linked_weight_definition {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NumericalWeight {
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CategoricalWeight {
        /// Index of "categorical_mapping". Maps a weight value for each categorical
        /// attribute value. See the dataspec for the mapping attribute value string
        /// to attribute value index.
        #[prost(float, repeated, tag="1")]
        pub categorical_value_idx_2_weight: ::prost::alloc::vec::Vec<f32>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// Weight definition if the controlling attribute is a numerical attribute.
        #[prost(message, tag="2")]
        Numerical(NumericalWeight),
        /// Weight definition if the controlling attribute is a categorical
        /// attribute.
        #[prost(message, tag="3")]
        Categorical(CategoricalWeight),
    }
}
// @@protoc_insertion_point(module)
